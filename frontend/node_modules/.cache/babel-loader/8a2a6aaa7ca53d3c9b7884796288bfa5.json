{"ast":null,"code":"module.exports = audioBufferToWav;\n\nfunction audioBufferToWav(buffer, opt) {\n  opt = opt || {};\n  var numChannels = buffer.numberOfChannels;\n  var sampleRate = buffer.sampleRate;\n  var format = opt.float32 ? 3 : 1;\n  var bitDepth = format === 3 ? 32 : 16;\n  var result;\n\n  if (numChannels === 2) {\n    result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));\n  } else {\n    result = buffer.getChannelData(0);\n  }\n\n  return encodeWAV(result, format, sampleRate, numChannels, bitDepth);\n}\n\nfunction encodeWAV(samples, format, sampleRate, numChannels, bitDepth) {\n  var bytesPerSample = bitDepth / 8;\n  var blockAlign = numChannels * bytesPerSample;\n  var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);\n  var view = new DataView(buffer);\n  /* RIFF identifier */\n\n  writeString(view, 0, 'RIFF');\n  /* RIFF chunk length */\n\n  view.setUint32(4, 36 + samples.length * bytesPerSample, true);\n  /* RIFF type */\n\n  writeString(view, 8, 'WAVE');\n  /* format chunk identifier */\n\n  writeString(view, 12, 'fmt ');\n  /* format chunk length */\n\n  view.setUint32(16, 16, true);\n  /* sample format (raw) */\n\n  view.setUint16(20, format, true);\n  /* channel count */\n\n  view.setUint16(22, numChannels, true);\n  /* sample rate */\n\n  view.setUint32(24, sampleRate, true);\n  /* byte rate (sample rate * block align) */\n\n  view.setUint32(28, sampleRate * blockAlign, true);\n  /* block align (channel count * bytes per sample) */\n\n  view.setUint16(32, blockAlign, true);\n  /* bits per sample */\n\n  view.setUint16(34, bitDepth, true);\n  /* data chunk identifier */\n\n  writeString(view, 36, 'data');\n  /* data chunk length */\n\n  view.setUint32(40, samples.length * bytesPerSample, true);\n\n  if (format === 1) {\n    // Raw PCM\n    floatTo16BitPCM(view, 44, samples);\n  } else {\n    writeFloat32(view, 44, samples);\n  }\n\n  return buffer;\n}\n\nfunction interleave(inputL, inputR) {\n  var length = inputL.length + inputR.length;\n  var result = new Float32Array(length);\n  var index = 0;\n  var inputIndex = 0;\n\n  while (index < length) {\n    result[index++] = inputL[inputIndex];\n    result[index++] = inputR[inputIndex];\n    inputIndex++;\n  }\n\n  return result;\n}\n\nfunction writeFloat32(output, offset, input) {\n  for (var i = 0; i < input.length; i++, offset += 4) {\n    output.setFloat32(offset, input[i], true);\n  }\n}\n\nfunction floatTo16BitPCM(output, offset, input) {\n  for (var i = 0; i < input.length; i++, offset += 2) {\n    var s = Math.max(-1, Math.min(1, input[i]));\n    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n  }\n}\n\nfunction writeString(view, offset, string) {\n  for (var i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i));\n  }\n}","map":{"version":3,"sources":["D:/ProjectFolder/Podcast Builder/frontend/node_modules/audiobuffer-to-wav/index.js"],"names":["module","exports","audioBufferToWav","buffer","opt","numChannels","numberOfChannels","sampleRate","format","float32","bitDepth","result","interleave","getChannelData","encodeWAV","samples","bytesPerSample","blockAlign","ArrayBuffer","length","view","DataView","writeString","setUint32","setUint16","floatTo16BitPCM","writeFloat32","inputL","inputR","Float32Array","index","inputIndex","output","offset","input","i","setFloat32","s","Math","max","min","setInt16","string","setUint8","charCodeAt"],"mappings":"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","sourcesContent":["module.exports = audioBufferToWav\nfunction audioBufferToWav (buffer, opt) {\n  opt = opt || {}\n\n  var numChannels = buffer.numberOfChannels\n  var sampleRate = buffer.sampleRate\n  var format = opt.float32 ? 3 : 1\n  var bitDepth = format === 3 ? 32 : 16\n\n  var result\n  if (numChannels === 2) {\n    result = interleave(buffer.getChannelData(0), buffer.getChannelData(1))\n  } else {\n    result = buffer.getChannelData(0)\n  }\n\n  return encodeWAV(result, format, sampleRate, numChannels, bitDepth)\n}\n\nfunction encodeWAV (samples, format, sampleRate, numChannels, bitDepth) {\n  var bytesPerSample = bitDepth / 8\n  var blockAlign = numChannels * bytesPerSample\n\n  var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample)\n  var view = new DataView(buffer)\n\n  /* RIFF identifier */\n  writeString(view, 0, 'RIFF')\n  /* RIFF chunk length */\n  view.setUint32(4, 36 + samples.length * bytesPerSample, true)\n  /* RIFF type */\n  writeString(view, 8, 'WAVE')\n  /* format chunk identifier */\n  writeString(view, 12, 'fmt ')\n  /* format chunk length */\n  view.setUint32(16, 16, true)\n  /* sample format (raw) */\n  view.setUint16(20, format, true)\n  /* channel count */\n  view.setUint16(22, numChannels, true)\n  /* sample rate */\n  view.setUint32(24, sampleRate, true)\n  /* byte rate (sample rate * block align) */\n  view.setUint32(28, sampleRate * blockAlign, true)\n  /* block align (channel count * bytes per sample) */\n  view.setUint16(32, blockAlign, true)\n  /* bits per sample */\n  view.setUint16(34, bitDepth, true)\n  /* data chunk identifier */\n  writeString(view, 36, 'data')\n  /* data chunk length */\n  view.setUint32(40, samples.length * bytesPerSample, true)\n  if (format === 1) { // Raw PCM\n    floatTo16BitPCM(view, 44, samples)\n  } else {\n    writeFloat32(view, 44, samples)\n  }\n\n  return buffer\n}\n\nfunction interleave (inputL, inputR) {\n  var length = inputL.length + inputR.length\n  var result = new Float32Array(length)\n\n  var index = 0\n  var inputIndex = 0\n\n  while (index < length) {\n    result[index++] = inputL[inputIndex]\n    result[index++] = inputR[inputIndex]\n    inputIndex++\n  }\n  return result\n}\n\nfunction writeFloat32 (output, offset, input) {\n  for (var i = 0; i < input.length; i++, offset += 4) {\n    output.setFloat32(offset, input[i], true)\n  }\n}\n\nfunction floatTo16BitPCM (output, offset, input) {\n  for (var i = 0; i < input.length; i++, offset += 2) {\n    var s = Math.max(-1, Math.min(1, input[i]))\n    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true)\n  }\n}\n\nfunction writeString (view, offset, string) {\n  for (var i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}