{"ast":null,"code":"var Transform = require('stream').Transform;\n\nvar extend = require('xtend');\n\nmodule.exports = AudioBufferStream;\n\nfunction AudioBufferStream(opt) {\n  var stream = new Transform(extend(opt, {\n    writableObjectMode: true\n  }));\n  opt = extend({\n    sampleRate: 44100,\n    channels: 2,\n    bitDepth: 32,\n    chunkLength: 256,\n    silenceDuration: null\n  }, opt);\n  var bytesPerChannel = opt.bitDepth / 8;\n  var bytesPerFrame = bytesPerChannel * opt.channels;\n\n  if (opt.bitDepth !== 32 && opt.bitDepth !== 16) {\n    throw new Error('bitDepth must be either 16 or 32');\n  }\n\n  var onDone = null;\n\n  stream._write = function (audioBuffer, enc, done) {\n    onDone = done;\n    var slices = audioBuffer.length / opt.chunkLength;\n\n    for (var i = 0; i < slices; i++) {\n      var start = i * opt.chunkLength;\n      var end = (i + 1) * opt.chunkLength;\n      var slice = [];\n\n      for (var c = 0; c < opt.channels; c++) {\n        var data = audioBuffer.getChannelData(c % audioBuffer.numberOfChannels);\n        slice[c] = data.subarray(start, end);\n      }\n\n      enqueue(slice);\n    }\n  };\n\n  var chunkId = 0;\n  var queue = [];\n  var silentFor = opt.silenceDuration || 0;\n  var processing = false;\n\n  function enqueue(data) {\n    queue.push(data);\n\n    if (!processing) {\n      processing = true;\n      process.nextTick(nextChunk);\n    }\n  }\n\n  function nextChunk() {\n    var data = queue.shift();\n    var isSilent = true;\n    var buffer = new Buffer(data[0].length * bytesPerFrame);\n\n    for (var c = 0; c < opt.channels; c++) {\n      var channel = data[c];\n      var channelOffset = c * bytesPerChannel;\n\n      for (var i = 0; i < channel.length; i++) {\n        var offset = i * bytesPerFrame + channelOffset;\n\n        if (opt.bitDepth === 32) {\n          buffer.writeFloatLE(channel[i], offset);\n        } else if (opt.bitDepth === 16) {\n          write16BitPCM(buffer, offset, channel[i]);\n        }\n\n        if (isSilent && hasSignal(channel[i])) {\n          isSilent = false;\n        }\n      }\n    }\n\n    if (isSilent) {\n      silentFor += data[0].length / opt.sampleRate;\n    } else {\n      silentFor = 0;\n    }\n\n    if (!isSilent || !opt.silenceDuration || opt.silenceDuration > silentFor) {\n      stream.push(buffer);\n      stream.emit('chunk', chunkId, true);\n    } else {\n      stream.emit('chunk', chunkId, false);\n    }\n\n    chunkId += 1;\n\n    if (queue.length) {\n      processing = true;\n      process.nextTick(nextChunk);\n    } else {\n      processing = false;\n      onDone && onDone();\n    }\n  }\n\n  return stream;\n}\n\nfunction write16BitPCM(output, offset, data) {\n  var s = Math.max(-1, Math.min(1, data));\n  output.writeInt16LE(Math.floor(s < 0 ? s * 0x8000 : s * 0x7FFF), offset);\n}\n\nfunction hasSignal(value) {\n  return value > 0.0001 || value < -0.0001;\n}","map":{"version":3,"sources":["D:/ProjectFolder/Podcast Builder/frontend/node_modules/audio-buffer-stream/index.js"],"names":["Transform","require","extend","module","exports","AudioBufferStream","opt","stream","writableObjectMode","sampleRate","channels","bitDepth","chunkLength","silenceDuration","bytesPerChannel","bytesPerFrame","Error","onDone","_write","audioBuffer","enc","done","slices","length","i","start","end","slice","c","data","getChannelData","numberOfChannels","subarray","enqueue","chunkId","queue","silentFor","processing","push","process","nextTick","nextChunk","shift","isSilent","buffer","Buffer","channel","channelOffset","offset","writeFloatLE","write16BitPCM","hasSignal","emit","output","s","Math","max","min","writeInt16LE","floor","value"],"mappings":"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","sourcesContent":["var Transform = require('stream').Transform\nvar extend = require('xtend')\nmodule.exports = AudioBufferStream\n\nfunction AudioBufferStream (opt) {\n  var stream = new Transform(extend(opt, {\n    writableObjectMode: true\n  }))\n\n  opt = extend({\n    sampleRate: 44100,\n    channels: 2,\n    bitDepth: 32,\n    chunkLength: 256,\n    silenceDuration: null\n  }, opt)\n\n  var bytesPerChannel = opt.bitDepth / 8\n  var bytesPerFrame = bytesPerChannel * opt.channels\n\n  if (opt.bitDepth !== 32 && opt.bitDepth !== 16) {\n    throw new Error('bitDepth must be either 16 or 32')\n  }\n\n  var onDone = null\n\n  stream._write = function (audioBuffer, enc, done) {\n    onDone = done\n    var slices = audioBuffer.length / opt.chunkLength\n    for (var i = 0; i < slices; i++) {\n      var start = i * opt.chunkLength\n      var end = (i + 1) * opt.chunkLength\n      var slice = []\n      for (var c = 0; c < opt.channels; c++) {\n        var data = audioBuffer.getChannelData(c % audioBuffer.numberOfChannels)\n        slice[c] = data.subarray(start, end)\n      }\n      enqueue(slice)\n    }\n  }\n\n  var chunkId = 0\n  var queue = []\n  var silentFor = opt.silenceDuration || 0\n  var processing = false\n\n  function enqueue (data) {\n    queue.push(data)\n    if (!processing) {\n      processing = true\n      process.nextTick(nextChunk)\n    }\n  }\n\n  function nextChunk () {\n    var data = queue.shift()\n\n    var isSilent = true\n    var buffer = new Buffer(data[0].length * bytesPerFrame)\n    for (var c = 0; c < opt.channels; c++) {\n      var channel = data[c]\n      var channelOffset = c * bytesPerChannel\n      for (var i = 0; i < channel.length; i++) {\n        var offset = i * bytesPerFrame + channelOffset\n\n        if (opt.bitDepth === 32) {\n          buffer.writeFloatLE(channel[i], offset)\n        } else if (opt.bitDepth === 16) {\n          write16BitPCM(buffer, offset, channel[i])\n        }\n\n        if (isSilent && hasSignal(channel[i])) {\n          isSilent = false\n        }\n      }\n    }\n\n    if (isSilent) {\n      silentFor += data[0].length / opt.sampleRate\n    } else {\n      silentFor = 0\n    }\n\n    if (!isSilent || !opt.silenceDuration || opt.silenceDuration > silentFor) {\n      stream.push(buffer)\n      stream.emit('chunk', chunkId, true)\n    } else {\n      stream.emit('chunk', chunkId, false)\n    }\n\n    chunkId += 1\n\n    if (queue.length) {\n      processing = true\n      process.nextTick(nextChunk)\n    } else {\n      processing = false\n      onDone && onDone()\n    }\n  }\n\n  return stream\n}\n\nfunction write16BitPCM (output, offset, data) {\n  var s = Math.max(-1, Math.min(1, data))\n  output.writeInt16LE(Math.floor(s < 0 ? s * 0x8000 : s * 0x7FFF), offset)\n}\n\nfunction hasSignal (value) {\n  return value > 0.0001 || value < -0.0001\n}\n"]},"metadata":{},"sourceType":"script"}